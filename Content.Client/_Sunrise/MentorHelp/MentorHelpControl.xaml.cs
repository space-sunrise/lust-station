using System.Linq;
using Content.Client.Administration.Systems;
using Content.Client.Administration.UI.Bwoink;
using Content.Shared._Sunrise.MentorHelp;
using Content.Shared.Administration;
using Content.Shared.Database;
using Robust.Client.AutoGenerated;
using Robust.Client.State;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Network;
using Robust.Shared.Timing;
using Robust.Shared.Configuration;
using Content.Shared._Sunrise.SunriseCCVars;
using Robust.Shared.Utility;
using Content.Client.Stylesheets;
using Robust.Shared.Localization;

namespace Content.Client._Sunrise.MentorHelp
{
    /// <summary>
    /// Main control for mentor help interface
    /// </summary>
    [GenerateTypedNameReferences]
    public sealed partial class MentorHelpControl : Control
    {
        [Dependency] private readonly IUserInterfaceManager _ui = default!;
        [Dependency] private readonly IConfigurationManager _cfg = default!;
        [Dependency] private readonly IGameTiming _gameTiming = default!;
        [Dependency] private readonly ILocalizationManager _loc = default!;

        private const double CloseConfirmTimeoutSeconds = 2;
        private const double TypingIndicatorTimeoutSeconds = 10;
        private bool _isDisposed;

        private MentorHelpSystem? _mentorHelpSystem;
        private NetUserId _ownerUserId;
        private bool _hasMentorPermissions;
        private List<MentorHelpTicketData> _tickets = new();
        private MentorHelpTicketData? _selectedTicket;
        private Dictionary<int, List<MentorHelpMessageData>> _ticketMessages = new();
        private readonly HashSet<int> _newMessageFromAuthorTickets = new();

        private readonly Dictionary<int, TicketEntryControl> _openTicketControls = new();
        private readonly Dictionary<int, TicketEntryControl> _closedTicketControls = new();

        private enum ViewState
        {
            TicketsList,
            TicketView
        }

        private MentorHelpNewTicketDialog? _newTicketDialog;
        private int? _pendingOpenTicketId;
        private List<string> PeopleTyping { get; set; } = new();
        private readonly Dictionary<string, TimeSpan> _typingTimeouts = new();
        public event Action<string>? InputTextChanged;

        private bool _closeConfirming;
        private int? _closeConfirmTicketId;
        private TimeSpan? _closeConfirmResetOn;

        public MentorHelpControl()
        {
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);

            _cfg.OnValueChanged(SunriseCCVars.MentorHelpSoundEnabled, OnMentorHelpSoundEnabledChanged, true);
            _cfg.OnValueChanged(SunriseCCVars.MentorHelpAutoOpenOnNewMessage, OnMentorHelpAutoOpenChanged, true);

            PlaySound.OnToggled += OnPlaySoundToggled;
            AutoOpenTickets.OnToggled += OnAutoOpenTicketsToggled;

            // Wire up button events
            NewTicketButton.OnPressed += _ => OpenNewTicketDialog();
            StatisticsButton.OnPressed += _ => _ui.GetUIController<MentorHelpStatisticsUIController>().ToggleStatistics();
            BackToListButton.OnPressed += _ => SwitchState(ViewState.TicketsList);

            // Wire up ticket action buttons
            ClaimButton.OnPressed += _ => ClaimTicket();
            UnassignButton.OnPressed += _ => UnassignTicket();
            CloseTicketButton.OnPressed += _ => CloseTicket();

            // Handle enter key in reply input
            ReplyInput.OnTextEntered += _ => SendReply();
            ReplyInput.OnTextChanged += Input_OnTextChanged;
            UpdateTypingIndicator();

            // Setup tab container like in AdminMenuWindow
            TicketsTabContainer.SetTabTitle(0, _loc.GetString("mentor-help-tab-open"));
            TicketsTabContainer.SetTabTitle(1, _loc.GetString("mentor-help-tab-closed"));

            // Handle tab changes to load closed tickets when needed
            TicketsTabContainer.OnTabChanged += OnTabChanged;

            AdminWhoButton.OnPressed += _ =>
            {
                var ctrl = _ui.GetUIController<AdminWhoUIController>();
                ctrl.Toggle();
            };

            // Set initial state
            SwitchState(ViewState.TicketsList);

            MessagesContainer.OnChildAdded += _ =>
            {
                MessagesScroll.VScrollTarget = float.MaxValue;
            };
        }

        private void OnPlaySoundToggled(BaseButton.ButtonToggledEventArgs args)
        {
            if (_isDisposed)
                return;

            _cfg.SetCVar(SunriseCCVars.MentorHelpSoundEnabled, args.Pressed);
        }

        private void OnAutoOpenTicketsToggled(BaseButton.ButtonToggledEventArgs args)
        {
            if (_isDisposed)
                return;

            _cfg.SetCVar(SunriseCCVars.MentorHelpAutoOpenOnNewMessage, args.Pressed);
        }

        private void OnMentorHelpSoundEnabledChanged(bool enabled)
        {
            PlaySound.Pressed = enabled;
        }

        private void OnMentorHelpAutoOpenChanged(bool enabled)
        {
            AutoOpenTickets.Pressed = enabled;
        }

        /// <summary>
        /// Попытаться открыть тикет с указанным id. Если тикет ещё не загружен, запросит список тикетов
        /// и откроет тикет когда список придёт.
        /// </summary>
        public void TryOpenTicket(int ticketId)
        {
            // If we already have the ticket loaded, select it immediately
            var ticket = _tickets.FirstOrDefault(t => t.Id == ticketId);
            if (ticket != null)
            {
                OnTicketSelected(ticket);
                return;
            }

            // Otherwise, remember to open when the list arrives and request tickets from server
            _pendingOpenTicketId = ticketId;
            _mentorHelpSystem?.RequestTickets(onlyMine: !_hasMentorPermissions);
        }

        public void Initialize(MentorHelpSystem? mentorHelpSystem, NetUserId ownerUserId, bool hasMentorPermissions)
        {
            _mentorHelpSystem = mentorHelpSystem;
            _ownerUserId = ownerUserId;
            _hasMentorPermissions = hasMentorPermissions;

            // Show/hide buttons based on permissions
            StatisticsButton.Visible = _hasMentorPermissions;
            UpdateTicketActionButtons();
        }

        private void OnTabChanged(int tabIndex)
        {
            // When switching to closed tickets tab, request all tickets including closed ones
            if (tabIndex == 1 && _hasMentorPermissions)
            {
                _mentorHelpSystem?.RequestTickets(onlyMine: false);
            }
            else if (tabIndex == 1 && !_hasMentorPermissions)
            {
                _mentorHelpSystem?.RequestTickets(onlyMine: true);
            }
        }

        // State switching like in LobbyGui
        private void SwitchState(ViewState state)
        {
            if (state == ViewState.TicketsList && _selectedTicket != null)
            {
                _mentorHelpSystem?.SendInputTextUpdated(_selectedTicket.Id, false);
                PeopleTyping.Clear();
                _typingTimeouts.Clear();
                UpdateTypingIndicator();
                ResetCloseConfirm();
            }

            DefaultState.Visible = false;
            TicketViewState.Visible = false;
            BackToListButton.Visible = false;

            switch (state)
            {
                case ViewState.TicketsList:
                    DefaultState.Visible = true;
                    _selectedTicket = null;
                    break;
                case ViewState.TicketView:
                    TicketViewState.Visible = true;
                    BackToListButton.Visible = true;
                    UpdateTicketHeader();
                    UpdateTicketActionButtons();
                    break;
            }
        }

        public void UpdateTicketsList(List<MentorHelpTicketData> tickets)
        {
            _tickets = tickets;
            RefreshTicketsList();

            // If we were asked to open a specific ticket once the list arrives, do it now
            if (_pendingOpenTicketId.HasValue)
            {
                var id = _pendingOpenTicketId.Value;
                _pendingOpenTicketId = null;
                var ticket = _tickets.FirstOrDefault(t => t.Id == id);
                if (ticket != null)
                {
                    OnTicketSelected(ticket);
                }
            }
        }

        // Refresh tickets like in ContributorsTop
        private void RefreshTicketsList()
        {
            var openTickets = _tickets.Where(t => t.Status != MentorHelpTicketStatus.Closed).ToList();
            var closedTickets = _tickets.Where(t => t.Status == MentorHelpTicketStatus.Closed).ToList();

            // Filter for players to show only their tickets
            if (!_hasMentorPermissions)
            {
                openTickets = openTickets.Where(t => t.PlayerId == _ownerUserId).ToList();
                closedTickets = closedTickets.Where(t => t.PlayerId == _ownerUserId).ToList();
            }

            // Update open tickets
            RefreshTicketTab(openTickets, _openTicketControls, OpenTicketsList);

            // Update closed tickets
            RefreshTicketTab(closedTickets, _closedTicketControls, ClosedTicketsList);
        }

        private void RefreshTicketTab(List<MentorHelpTicketData> tickets, Dictionary<int, TicketEntryControl> controls, BoxContainer container)
        {
            var sortedTickets = tickets.OrderByDescending(t => t.UpdatedAt).ToList();

            // Remove tickets that no longer exist
            var toRemove = controls.Keys.Where(id => !sortedTickets.Any(t => t.Id == id)).ToList();
            foreach (var id in toRemove)
            {
                if (controls.TryGetValue(id, out var control))
                {
                    container.RemoveChild(control);
                    controls.Remove(id);
                }
            }

            // Add or update existing tickets
            foreach (var ticket in sortedTickets)
            {
                if (controls.TryGetValue(ticket.Id, out var existingControl))
                {
                    existingControl.UpdateData(ticket);
                    existingControl.SetNewMessageFromAuthor(_newMessageFromAuthorTickets.Contains(ticket.Id));
                }
                else
                {
                    var control = new TicketEntryControl();
                    control.UpdateData(ticket);
                    control.SetNewMessageFromAuthor(_newMessageFromAuthorTickets.Contains(ticket.Id));
                    control.OnTicketSelected += OnTicketSelected;
                    controls[ticket.Id] = control;
                    container.AddChild(control);
                }
            }
        }

        private void OnTicketSelected(MentorHelpTicketData ticket)
        {
            if (_selectedTicket != null)
                _mentorHelpSystem?.SendInputTextUpdated(_selectedTicket.Id, false);

            _selectedTicket = ticket;
            PeopleTyping.Clear();
            _typingTimeouts.Clear();
            UpdateTypingIndicator();
            ReplyInput.Text = string.Empty;
            ResetCloseConfirm();

            _newMessageFromAuthorTickets.Remove(ticket.Id);
            ticket.HasUnreadMessages = false;
            UpdateTicket(ticket);
            SwitchState(ViewState.TicketView);

            // Clear previous messages first
            MessagesContainer.RemoveAllChildren();

            // Request messages for this ticket
            _mentorHelpSystem?.RequestTicketMessages(ticket.Id);
        }

        public void UpdateTicketMessages(int ticketId, List<MentorHelpMessageData> messages)
        {
            _ticketMessages[ticketId] = messages;

            var ticketIndex = _tickets.FindIndex(t => t.Id == ticketId);
            if (ticketIndex >= 0 && messages.Count > 0)
            {
                var ticket = _tickets[ticketIndex];
                var lastMessage = messages[^1];

                if (ticket.UpdatedAt < lastMessage.SentAt)
                    ticket.UpdatedAt = lastMessage.SentAt;

                var isViewingTicket = _selectedTicket?.Id == ticketId && TicketViewState.Visible;

                var isRelevant = !_hasMentorPermissions
                    ? ticket.PlayerId == _ownerUserId
                    : ticket.AssignedToUserId == null || ticket.AssignedToUserId == _ownerUserId;

                if (isRelevant)
                {
                    var unread = !isViewingTicket && lastMessage.SenderUserId != _ownerUserId;
                    ticket.HasUnreadMessages = unread;

                    if (_hasMentorPermissions && unread && lastMessage.SenderUserId == ticket.PlayerId)
                        _newMessageFromAuthorTickets.Add(ticketId);
                    else
                        _newMessageFromAuthorTickets.Remove(ticketId);
                }
                else
                {
                    ticket.HasUnreadMessages = false;
                    _newMessageFromAuthorTickets.Remove(ticketId);
                }

                _tickets[ticketIndex] = ticket;
                RefreshTicketsList();
            }

            if (_selectedTicket?.Id == ticketId && TicketViewState.Visible)
            {
                DisplayTicketMessages(messages);
                ScrollToBottomDeferred();
            }
        }

        public void UpdateTicket(MentorHelpTicketData ticket)
        {
            // Update ticket in our list
            var index = _tickets.FindIndex(t => t.Id == ticket.Id);
            if (index >= 0)
            {
                _tickets[index] = ticket;
            }
            else
            {
                _tickets.Add(ticket);
            }

            // Update selected ticket if it's the one that changed
            if (_selectedTicket?.Id == ticket.Id)
            {
                _selectedTicket = ticket;
                if (TicketViewState.Visible)
                {
                    UpdateTicketHeader();
                    UpdateTicketActionButtons();
                }
            }

            // If admin closed the ticket while player was viewing it, return to list
            if (ticket.Status == MentorHelpTicketStatus.Closed &&
                _selectedTicket?.Id == ticket.Id &&
                !_hasMentorPermissions &&
                TicketViewState.Visible)
            {
                SwitchState(ViewState.TicketsList);
            }

            // Refresh the list to show updated status
            RefreshTicketsList();
        }

        private void UpdateTicketHeader()
        {
            if (_selectedTicket == null)
                return;

            // Отдельные метки для ID и темы (чтобы занимали меньше места и были выровнены)
            TicketIdLabel.Text = $"#{_selectedTicket.Id}";
            TicketSubjectLabel.Text = _selectedTicket.Subject;

            // Компактная строка: статус | назначен | создано
            TicketStatus.Text = _loc.GetString("mentor-help-status-label", ("status", GetStatusText(_selectedTicket.Status)));
            TicketAssigned.Text = _loc.GetString("mentor-help-assigned-label",
                ("assigned", _selectedTicket.AssignedToName ?? _loc.GetString("mentor-help-unassigned")));
            TicketCreated.Text = _loc.GetString("mentor-help-created-label",
                ("created", _selectedTicket.CreatedAt.ToString("dd.MM.yyyy HH:mm")));
        }

        private void UpdateTicketActionButtons()
        {
            if (_selectedTicket == null)
            {
                ReplyPanel.Visible = false;
                return;
            }

            var canReply = _selectedTicket.Status != MentorHelpTicketStatus.Closed;
            var isAssignedToMe = _selectedTicket.AssignedToUserId == _ownerUserId;
            var isOpen = _selectedTicket.Status != MentorHelpTicketStatus.Closed;
            var isUnassigned = _selectedTicket.AssignedToUserId == null;

            // Hide reply panel for closed tickets
            ReplyPanel.Visible = canReply;

            if (!isOpen)
                ResetCloseConfirm();

            if (_hasMentorPermissions)
            {
                ClaimButton.Visible = isOpen && isUnassigned;
                UnassignButton.Visible = isOpen && isAssignedToMe;
                CloseTicketButton.Visible = isOpen;
            }
            else
            {
                ClaimButton.Visible = false;
                UnassignButton.Visible = false;
                CloseTicketButton.Visible = isOpen; // Players can close their own tickets
            }
        }

        private void ResetCloseConfirm()
        {
            _closeConfirming = false;
            _closeConfirmTicketId = null;
            _closeConfirmResetOn = null;
            CloseTicketButton.Text = _loc.GetString("mentor-help-close-ticket");
            CloseTicketButton.StyleClasses.Remove(StyleNano.StyleClassButtonColorRed);
        }

        private string GetStatusText(MentorHelpTicketStatus status)
        {
            return status switch
            {
                MentorHelpTicketStatus.Open => _loc.GetString("mentor-help-status-open"),
                MentorHelpTicketStatus.Assigned => _loc.GetString("mentor-help-status-assigned"),
                MentorHelpTicketStatus.AwaitingResponse => _loc.GetString("mentor-help-status-awaiting"),
                MentorHelpTicketStatus.Closed => _loc.GetString("mentor-help-status-closed"),
                _ => _loc.GetString("mentor-help-status-unknown")
            };
        }

        private void DisplayTicketMessages(List<MentorHelpMessageData> messages)
        {
            MessagesContainer.RemoveAllChildren();
            DateTime? lastDate = null;

            foreach (var message in messages.OrderBy(m => m.SentAt))
            {
                var sentAt = message.SentAt;
                var sentDate = sentAt.Date;

                if (lastDate == null || lastDate.Value != sentDate)
                {
                    lastDate = sentDate;

                    var dateLabel = new RichTextLabel
                    {
                        HorizontalExpand = true,
                        Margin = new Thickness(0, 10, 0, 5)
                    };

                    dateLabel.Text = $"[center][bold]{sentAt:dd.MM.yyyy}[/bold][/center]";

                    MessagesContainer.AddChild(dateLabel);
                }

                var messageBox = new BoxContainer
                {
                    Orientation = BoxContainer.LayoutOrientation.Vertical,
                    Margin = new Thickness(0, 4)
                };

                var nameLine = new RichTextLabel();
                nameLine.Text = $"[bold]{sentAt:HH:mm}[/bold] {message.FormattedSender}:";

                var textLine = new RichTextLabel
                {
                    HorizontalExpand = true
                };
                textLine.Text = message.Message;

                messageBox.AddChild(nameLine);
                messageBox.AddChild(textLine);

                MessagesContainer.AddChild(messageBox);
            }
        }

        private void ScrollToBottomDeferred()
        {
            _ui.DeferAction(() =>
            {
                MessagesScroll.VScrollTarget = float.MaxValue;
            });
        }


        private void OpenNewTicketDialog()
        {
            if (_newTicketDialog != null)
            {
                _newTicketDialog.Close();
                _newTicketDialog = null;
                return;
            }

            _newTicketDialog = new MentorHelpNewTicketDialog();
            _newTicketDialog.OnTicketCreated += (subject, message) =>
            {
                _newTicketDialog?.Close();
                _mentorHelpSystem?.CreateTicket(subject, message);
            };
            _newTicketDialog.OnClose += () => _newTicketDialog = null;
            _newTicketDialog.OpenCentered();
        }

        private void SendReply()
        {
            if (_selectedTicket == null || string.IsNullOrWhiteSpace(ReplyInput.Text))
                return;

            _mentorHelpSystem?.ReplyToTicket(_selectedTicket.Id, ReplyInput.Text.Trim());
            ReplyInput.Text = string.Empty;
        }

        private void ClaimTicket()
        {
            if (_selectedTicket == null)
                return;

            _mentorHelpSystem?.ClaimTicket(_selectedTicket.Id);
        }

        private void UnassignTicket()
        {
            if (_selectedTicket == null)
                return;

            _mentorHelpSystem?.UnassignTicket(_selectedTicket.Id);
        }

        private void CloseTicket()
        {
            if (_selectedTicket == null)
                return;

            if (!_closeConfirming || _closeConfirmTicketId != _selectedTicket.Id)
            {
                _closeConfirming = true;
                _closeConfirmTicketId = _selectedTicket.Id;
                _closeConfirmResetOn = _gameTiming.RealTime + TimeSpan.FromSeconds(CloseConfirmTimeoutSeconds);
                CloseTicketButton.Text = _loc.GetString("mentor-help-close-confirm");
                CloseTicketButton.StyleClasses.Add(StyleNano.StyleClassButtonColorRed);

                return;
            }

            ResetCloseConfirm();
            _mentorHelpSystem?.CloseTicket(_selectedTicket.Id);
        }

        private void UpdateTypingIndicator()
        {
            var msg = new FormattedMessage();
            msg.PushColor(Color.LightGray);

            var text = PeopleTyping.Count == 0
                ? string.Empty
                : _loc.GetString("bwoink-system-typing-indicator",
                    ("players", string.Join(", ", PeopleTyping)),
                    ("count", PeopleTyping.Count));

            msg.AddText(text);
            msg.Pop();

            TypingIndicator.SetMessage(msg);
        }

        public void UpdatePlayerTyping(int ticketId, string name, bool typing)
        {
            if (_selectedTicket?.Id != ticketId || !TicketViewState.Visible)
                return;

            if (typing)
            {
                var now = _gameTiming.RealTime;
                _typingTimeouts[name] = now + TimeSpan.FromSeconds(TypingIndicatorTimeoutSeconds);

                if (!PeopleTyping.Contains(name))
                    PeopleTyping.Add(name);
            }
            else
            {
                PeopleTyping.Remove(name);
                _typingTimeouts.Remove(name);
            }

            UpdateTypingIndicator();
        }

        private void Input_OnTextChanged(LineEdit.LineEditEventArgs args)
        {
            InputTextChanged?.Invoke(args.Text);

            if (_selectedTicket == null)
                return;

            _mentorHelpSystem?.SendInputTextUpdated(_selectedTicket.Id, args.Text.Length > 0);
        }

        protected override void FrameUpdate(FrameEventArgs args)
        {
            base.FrameUpdate(args);

            if (Disposed)
                return;

            var now = _gameTiming.RealTime;

            if (_closeConfirmResetOn < now)
            {
                if (_closeConfirming && _closeConfirmTicketId == _selectedTicket?.Id)
                    ResetCloseConfirm();

                _closeConfirmResetOn = null;
            }

            if (PeopleTyping.Count == 0)
                return;

            var updatedTypingIndicator = false;

            for (var g = PeopleTyping.Count - 1; g >= 0; g--)
            {
                var name = PeopleTyping[g];

                if (!_typingTimeouts.TryGetValue(name, out var timeoutAt) || timeoutAt > now)
                    continue;

                PeopleTyping.RemoveAt(g);
                _typingTimeouts.Remove(name);
                updatedTypingIndicator = true;
            }

            if (updatedTypingIndicator)
                UpdateTypingIndicator();
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (!disposing)
                return;

            _isDisposed = true;

            PlaySound.OnToggled -= OnPlaySoundToggled;
            AutoOpenTickets.OnToggled -= OnAutoOpenTicketsToggled;

            _cfg.UnsubValueChanged(SunriseCCVars.MentorHelpSoundEnabled, OnMentorHelpSoundEnabledChanged);
            _cfg.UnsubValueChanged(SunriseCCVars.MentorHelpAutoOpenOnNewMessage, OnMentorHelpAutoOpenChanged);
        }
    }
}
