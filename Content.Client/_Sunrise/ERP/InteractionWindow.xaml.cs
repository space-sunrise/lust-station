// © SUNRISE, An EULA/CLA with a hosting restriction, full text: https://github.com/space-sunrise/lust-station/blob/master/CLA.txt
using Robust.Client.UserInterface.XAML;
using Robust.Client.AutoGenerated;
using Content.Shared._Sunrise.ERP;
using Robust.Client.GameObjects;
using Content.Shared.Humanoid;
using Robust.Client.UserInterface.Controls;
using Content.Shared.IdentityManagement;
using Robust.Client.Player;
using Robust.Shared.Prototypes;
using Robust.Client.Graphics;
using Robust.Shared.Timing;
using System.Linq;
using Content.Shared.Hands.Components;
using Content.Client.Stylesheets;
using Content.Shared._Sunrise.ERP.Components;
using Content.Client.UserInterface.Controls;
using Robust.Shared.Containers;
using Content.Shared.Tag;
using Content.Shared.Clothing.Components;

namespace Content.Client._Sunrise.ERP;

[GenerateTypedNameReferences]
public sealed partial class InteractionWindow : FancyWindow
{
    [Dependency] private readonly EntityManager _entManager = default!;
    [Dependency] private readonly IPlayerManager _player = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IGameTiming _gameTiming = default!;
    private readonly SpriteSystem _spriteSystem;
    private readonly InteractionEui _eui;
    public NetEntity? TargetEntityId { get; set; }
    public Sex UserSex { get; set; }
    public Sex TargetSex { get; set; }
    public bool UserHasClothing { get; set; }
    public bool TargetHasClothing { get; set; }

    /// <summary>
    /// ЕРП-статус
    /// </summary>
    public bool Erp { get; set; }

    public HashSet<string>? UserTags { get; set; }
    public HashSet<string>? TargetTags { get; set; }
    public ProgressBar LoveBar;
    public TimeSpan TimeUntilAllow = TimeSpan.Zero;
    public TimeSpan UntilUpdate = TimeSpan.Zero;
    public InteractionWindow(InteractionEui eui)
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);
        _spriteSystem = _entManager.System<SpriteSystem>();
        _eui = eui;
        LoveBar = ProgressBar;
        SearchBar.OnTextChanged += SearchBarOnOnTextChanged;
        ProgressBar.ForegroundStyleBoxOverride = new StyleBoxFlat(backgroundColor: new Color(247, 141, 141));
        ProgressBar.BackgroundStyleBoxOverride = new StyleBoxFlat(backgroundColor: new Color(152, 24, 84));
        ButtonGroup Group = new();
        InteractionButton.Group = Group;
        DescriptionButton.Group = Group;
        DevButton.Group = Group;
        InteractionButton.Pressed = true;
        InteractionButton.OnPressed += SetModeToInteraction;
        DescriptionButton.OnPressed += SetModeToDescription;
        DevButton.OnPressed += SetModeToDev;
        PopulateByFilter("", false);
        ModeButtons.Visible = true;
        // TODO: Спрайты для описаний.
        DescriptionButton.Visible = false;
        // Dev Window
        DevButton.Visible = false;
    }

    private void SetModeToInteraction(BaseButton.ButtonEventArgs obj)
    {
        SearchBar.Visible = true;
        ItemInteractions.Visible = true;
        DescriptionContainer.Visible = false;
        DevContainer.Visible = false;
    }

    private void SetModeToDescription(BaseButton.ButtonEventArgs obj)
    {
        SearchBar.Visible = false;
        ItemInteractions.Visible = false;
        DescriptionContainer.Visible = true;
        DevContainer.Visible = false;
        DescriptionPopulate();
    }

    private void SetModeToDev(BaseButton.ButtonEventArgs obj)
    {
        SearchBar.Visible = false;
        ItemInteractions.Visible = false;
        DescriptionContainer.Visible = false;
        DevContainer.Visible = true;
        DevPopulate();
    }

    private void DescriptionPopulate()
    {
        DescriptionLeft.DisposeAllChildren();
        DescriptionRight.DisposeAllChildren();

        if (!_player.LocalEntity.HasValue)
            return;

        if (!_entManager.TryGetComponent<InteractionComponent>(_player.LocalEntity.Value, out var userInteraction))
            return;

        if (!_entManager.TryGetComponent<HumanoidAppearanceComponent>(_player.LocalEntity.Value, out var userHumanoid))
            return;

        SpriteLeft.SetEntity(_player.LocalEntity.Value);
        UserName.Text = $"{Identity.Name(_player.LocalEntity.Value,
                        _eui._entManager, _player.LocalEntity.Value)}\n\n{Loc.GetString(
                        $"erp-panel-sex-{UserSex.ToString().ToLowerInvariant()}-text")}";
        UserName.SetOnlyStyleClass(StyleNano.StyleClassLabelSmall);

        foreach (var sprite in userInteraction.GenitalSprites)
        {
            if (UserHasClothing)
                break;

            var texture = new TextureRect();

            texture.TexturePath = sprite;
            texture.SetSize = new(125, 125);
            texture.VerticalAlignment = VAlignment.Top;
            texture.HorizontalAlignment = HAlignment.Center;
            texture.Stretch = TextureRect.StretchMode.KeepAspectCentered;
            texture.Modulate = userHumanoid.SkinColor;
            texture.Margin = new(15);
            DescriptionLeft.AddChild(texture);
        }

        var targets = _entManager.GetEntity(TargetEntityId);
        if (!targets.HasValue) return;
        var target = targets.Value;

        if (!TargetEntityId.HasValue)
            return;


        if (!_entManager.TryGetComponent<InteractionComponent>(target, out var targetInteraction))
            return;

        if (!_entManager.TryGetComponent<HumanoidAppearanceComponent>(target, out var targetHumanoid))
            return;

        SpriteRight.SetEntity(target);
        // TargetName.Text = $"{Identity.Name(target, _eui._entManager, _player.LocalEntity.Value)}\n\n{Loc.GetString($"erp-panel-sex-{TargetSex.Value.ToString().ToLowerInvariant()}-text")}";
        TargetName.SetOnlyStyleClass(StyleNano.StyleClassLabelSmall);
        foreach (var sprite in targetInteraction.GenitalSprites)
        {
            if (TargetHasClothing)
                break;

            var texture = new TextureRect();
            texture.TexturePath = sprite;
            texture.SetSize = new(125, 125);
            texture.VerticalAlignment = VAlignment.Top;
            texture.HorizontalAlignment = HAlignment.Center;
            texture.Stretch = TextureRect.StretchMode.KeepAspectCentered;
            texture.Margin = new(15);
            texture.Modulate = targetHumanoid.SkinColor;
            DescriptionRight.AddChild(texture);
        }
    }

    private void DevPopulate()
    {

        if (!_player.LocalEntity.HasValue)
            return;

        if (UserTags != null)
        {
            foreach (var tag in UserTags)
            {
                DevLeft.AddItem(tag, null, false);
            }
        }

        if (!TargetEntityId.HasValue)
            return;

        if (TargetTags != null)
        {
            foreach (var tag in TargetTags)
            {
                DevRight.AddItem(tag, null, false);
            }
        }
    }

    private void SearchBarOnOnTextChanged(LineEdit.LineEditEventArgs obj)
    {
        PopulateByFilter(SearchBar.Text);
    }
    private List<(string, Robust.Client.Graphics.Texture, InteractionPrototype)> oldItemList = new();
    private void PopulateByFilter(string filter, bool check = true)
    {
        if (!_player.LocalEntity.HasValue)
            return;

        if (!TargetEntityId.HasValue)
            return;

        var targets = _entManager.GetEntity(TargetEntityId);
        if (!targets.HasValue) return;
        var uid = _player.LocalEntity.Value;
        var tid = targets.Value;        
        if (!_entManager.TryGetComponent<ContainerManagerComponent>(uid, out var UserInventory)) return;
        if (!_entManager.TryGetComponent<ContainerManagerComponent>(tid, out var TargetInventory)) return;
        
        HashSet<string> UserCategories = GetRestrictedTags(UserTags, UserInventory);
        HashSet<string> TargetCategories = GetRestrictedTags(TargetTags, TargetInventory);

        var protos = _prototypeManager.EnumeratePrototypes<InteractionPrototype>().ToArray();

        Array.Sort(protos, (x, y) => x.SortOrder.CompareTo(y.SortOrder));
        List<(string, Robust.Client.Graphics.Texture, InteractionPrototype)> itemList = new();
        foreach (string category in new List<string>
        {"standart", "дружба", "щёки", "губы", "шея", "волосы", "хвост", "крылья",
        "рот", "грудь", "ступни", "ляжки", "попа", "яйца", "член", "вагина", "анал",
            "лицо", "рога", "уши"}
        )
        {
            foreach (var proto in protos)
            {

                if (proto.InhandObject.Count > 0)
                {
                    if (_entManager.TryGetComponent<HandsComponent>(uid, out var hands))
                    {
                        if (hands.ActiveHand == null)
                            continue;

                        if (hands.ActiveHand.Container == null)
                            continue;

                        if (!hands.ActiveHand.Container.ContainedEntity.HasValue)
                            continue;

                        if (!_entManager.TryGetComponent<MetaDataComponent>(hands.ActiveHand.Container.ContainedEntity.Value, out var meta))
                            continue;

                        if (meta.EntityPrototype == null)
                            continue;

                        if (!proto.InhandObject.Contains(meta.EntityPrototype.ID))
                            continue;
                    }
                }

                if (proto.Category.ToLower() != category)
                    continue;

                if (_entManager.GetEntity(TargetEntityId.Value) == _player.LocalEntity.Value && !proto.UseSelf)
                    continue;

                if (_entManager.GetEntity(TargetEntityId.Value) != _player.LocalEntity.Value && proto.UseSelf)
                    continue;

                if (string.IsNullOrEmpty(filter) ||
                    proto.Name.ToLowerInvariant().Contains(filter.Trim().ToLowerInvariant()))
                {
                    var texture = _spriteSystem.Frame0(proto.Icon);

                    if (UserHasClothing && proto.UserWithoutCloth) continue;

                    if (TargetHasClothing && proto.TargetWithoutCloth) continue;

                    if (!proto.UserSex.Contains(UserSex) && !proto.UserSex.Contains(Sex.Unsexed))
                        continue;

                    if (!proto.TargetSex.Contains(TargetSex) && !proto.TargetSex.Contains(Sex.Unsexed))
                        continue;

                    if (!Erp && proto.Erp)
                        continue;

                    if (!AreTagsAllowed(UserTags, proto.UserTagWhitelist, proto.UserTagBlacklist, UserCategories))
                        goto CONTINUE;

                    if (!AreTagsAllowed(TargetTags, proto.TargetTagWhitelist, proto.TargetTagBlacklist, TargetCategories))
                        goto CONTINUE;

                    //ItemInteractions.AddItem(proto.Name, texture, metadata: proto);
                    itemList.Add((proto.Name, texture, proto));
                }
            CONTINUE:;
            }
        }
        bool equals = true;
        foreach (var i in oldItemList)
        {
            if (!itemList.Contains(i))
            {
                equals = false;
                break;
            }
        }
        foreach (var i in itemList)
        {
            if (!oldItemList.Contains(i))
            {
                equals = false;
                break;
            }
        }
        if (!equals || !check)
        {
            ItemInteractions.Clear();
            foreach (var i in itemList)
            {
                ItemInteractions.AddItem(i.Item1, i.Item2, metadata: i.Item3);
            }
        }


        oldItemList = itemList;
    }
    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);
        _eui.FrameUpdate(args);
        if (_gameTiming.CurTime <= UntilUpdate)
            return;

        UntilUpdate = _gameTiming.CurTime + TimeSpan.FromSeconds(1);
        _eui.RequestState();
    }


    public void Populate()
    {
        var prototypes = _prototypeManager.EnumeratePrototypes<InteractionPrototype>().ToList();

        UserDescription.DisposeAllChildren();
        TargetDescription.DisposeAllChildren();

        //Проверки nullable-типов
        if (!TargetEntityId.HasValue
         || !_player.LocalEntity.HasValue)
            return;

        //Аминь
        if (Erp)
        {
            //Юзер
            UserDescription.AddChild(new Label { Text = "Вы...", StyleClasses = { StyleNano.StyleClassLabelBig } }); ;
            UserDescription.AddChild(new Label { Text = "...Обладаете анусом" });

            if (UserHasClothing)
                UserDescription.AddChild(new Label { Text = "...Обладаете одеждой" });
            else UserDescription.AddChild(new Label { Text = "...Не обладаете одеждой" });

            if (UserSex == Sex.Male)
                UserDescription.AddChild(new Label { Text = "...Обладаете пенисом" });

            if (UserSex == Sex.Female)
            {
                UserDescription.AddChild(new Label { Text = "...Обладаете вагиной" });
                UserDescription.AddChild(new Label { Text = "...Обладаете грудью" });
            }
            if (UserSex == Sex.Futanari)
            {
                UserDescription.AddChild(new Label { Text = "...Обладаете вагиной" });
                UserDescription.AddChild(new Label { Text = "...Обладаете пенисом" });
                UserDescription.AddChild(new Label { Text = "...Обладаете грудью" });
            }
            //Таргет
            if (_entManager.GetEntity(TargetEntityId.Value) != _player.LocalEntity.Value)
            {
                TargetDescription.AddChild(new Label { Text = Identity.Name(_eui._entManager.GetEntity(TargetEntityId.Value), _eui._entManager, _player.LocalEntity.Value) + "...", StyleClasses = { StyleNano.StyleClassLabelBig } });
                if (TargetHasClothing)
                    TargetDescription.AddChild(new Label { Text = "...Обладает одеждой" });
                else
                {
                    TargetDescription.AddChild(new Label { Text = "...Не обладает одеждой" });
                    TargetDescription.AddChild(new Label { Text = "...Обладает анусом" });

                    if (TargetSex == Sex.Male)
                        TargetDescription.AddChild(new Label { Text = "...Обладает пенисом" });

                    if (TargetSex == Sex.Futanari)
                    {
                        TargetDescription.AddChild(new Label { Text = "...Обладаете вагиной" });
                        TargetDescription.AddChild(new Label { Text = "...Обладаете пенисом" });
                    }

                    if (TargetSex == Sex.Female)
                        TargetDescription.AddChild(new Label { Text = "...Обладает вагиной" });

                }
                if (TargetSex == Sex.Female)
                    TargetDescription.AddChild(new Label { Text = "...Обладает грудью" });

                if (TargetSex == Sex.Futanari)
                {
                    TargetDescription.AddChild(new Label { Text = "...Обладает подозрительной аурой" });
                    TargetDescription.AddChild(new Label { Text = "...Обладает грудью" });
                }
            }
        }
        else ErpProgress.Dispose();

        if (DescriptionContainer.Visible)
        {
            DescriptionPopulate();
        }
        else
        {
            PopulateByFilter(SearchBar.Text);
        }
        ItemInteractions.OnItemSelected += _eui.OnItemSelect;
    }

    private HashSet<string> GetRestrictedTags(HashSet<string>? tags, ContainerManagerComponent inventory)
    {
        HashSet<string> Categories = new HashSet<string> {""};
        HashSet<string> ItemCategories = new HashSet<string> {""};

        if (tags == null)
        {
            return Categories;
        }
        foreach(var tag in tags)
        {
            switch(tag)
                {
                    case "jumpsuit":
                    {
                        if (inventory.Containers.TryGetValue("jumpsuit", out var con))
                        {
                            ItemCategories = new HashSet<string> {"грудь", "ляжки", "попа", "яйца", "член", "вагина", "анал"};
                            if (_entManager.TryGetComponent<TagComponent>(con.ContainedEntities[0], out var ClothingTags))
                            foreach (var tgs in ClothingTags.Tags)
                            {
                                if (tgs == "NudeBottom") {ItemCategories = new HashSet<string> {"грудь"}; break;}
                                if (tgs == "NudeTop") {ItemCategories = new HashSet<string> {"ляжки", "попа", "яйца", "член", "вагина", "анал"}; break;}
                                if (tgs == "CommandSuit") {ItemCategories = new HashSet<string> {"грудь", "ляжки", "попа", "вагина", "анал"}; break;}
                            }  
                            Categories.UnionWith(ItemCategories);
                        }
                        break;
                    }

                    case "outerClothing":
                    {
                        if (inventory.Containers.TryGetValue("outerClothing", out var con))
                        {
                            ItemCategories = new HashSet<string> {"грудь", "ляжки", "попа", "яйца", "член", "вагина", "анал"};
                            if (_entManager.TryGetComponent<TagComponent>(con.ContainedEntities[0], out var ClothingTags))
                            foreach (var tgs in ClothingTags.Tags)
                            {
                                if (tgs == "NudeBottom") {ItemCategories = new HashSet<string> {"грудь"}; break;}
                                if (tgs == "NudeFull") {ItemCategories = new HashSet<string> {}; break;}
                                if (tgs == "FullCovered") {ItemCategories = new HashSet<string> {"щёки", "губы", "шея", "уши", "волосы",
                                "рот", "грудь", "ступни", "ляжки", "попа", "яйца", "член", "вагина", "анал", "лицо", "хвост", "ладони", "гладкие перчатки"}; break;}
                                if (tgs == "FullBodyOuter") {ItemCategories = new HashSet<string> {"грудь", "ступни", "ляжки", "попа", "яйца", "член", "вагина", "анал", "шея", "ладони", "гладкие перчатки"}; break;}
                            }  
                            Categories.UnionWith(ItemCategories);
                        }
                        break;
                    }
                    

                    case "head":
                    {
                        if (inventory.Containers.TryGetValue("head", out var con))
                        {
                            ItemCategories = new HashSet<string> {"волосы"};
                            if (_entManager.TryGetComponent<TagComponent>(con.ContainedEntities[0], out var ClothingTags))
                            foreach (var tgs in ClothingTags.Tags)
                            {
                                if (tgs == "TopCovered") {ItemCategories = new HashSet<string> {"уши", "волосы"}; break;}
                                if (tgs == "FullCovered") {ItemCategories = new HashSet<string> {"уши", "волосы", "рот", "лицо", "губы", "щёки"}; break;}
                            }  
                            Categories.UnionWith(ItemCategories);
                        }
                        break;
                    }

                    case "gloves":
                    {
                        if (inventory.Containers.TryGetValue("gloves", out var con))
                        {
                            ItemCategories = new HashSet<string> {"ладони", "гладкие перчатки"};
                            if (_entManager.TryGetComponent<TagComponent>(con.ContainedEntities[0], out var ClothingTags))
                            foreach (var tgs in ClothingTags.Tags)
                            {
                                if (tgs == "SmoothGloves") {ItemCategories = new HashSet<string> {"ладони"}; break;}
                                if (tgs == "Ring") {ItemCategories = new HashSet<string> {}; break;}
                            }  
                            Categories.UnionWith(ItemCategories); break;
                        }
                        break;
                    }
                    
                    case "mask":
                    {
                        if (inventory.Containers.TryGetValue("mask", out var con))
                        {
                            ItemCategories = new HashSet<string> {"рот"};
                            if (_entManager.TryGetComponent<MaskComponent>(con.ContainedEntities[0], out var ClothingTags))
                            if (ClothingTags.IsToggled)
                            ItemCategories = new HashSet<string> {};
                            Categories.UnionWith(ItemCategories); 
                        }
                        break;
                    }
                    

                    case "bra":
                    {
                        ItemCategories = new HashSet<string> {"грудь"};
                        Categories.UnionWith(ItemCategories); 
                        break;
                    }

                    case "pants":
                    {
                        ItemCategories = new HashSet<string> {"яйца", "член", "вагина", "анал"};
                        Categories.UnionWith(ItemCategories); 
                        break;
                    }

                    case "socks":
                    {
                        ItemCategories = new HashSet<string> {"ступни"};
                        Categories.UnionWith(ItemCategories); break;
                    }

                    case "shoes":
                    {
                        ItemCategories = new HashSet<string> {"носки", "ступни"};
                        Categories.UnionWith(ItemCategories); 
                        break;
                    }

                    case "neck":
                    {
                        ItemCategories = new HashSet<string> {"шея"};
                        Categories.UnionWith(ItemCategories); 
                        break;
                    }

                    default: 
                        break;
                }
        }
        

        return Categories;
    }

    private static bool AreTagsAllowed(HashSet<string>? tags, HashSet<string> whiteListTags, HashSet<string> blackListTags,  HashSet<string> categories)
    {

         bool state = true;
        if (tags != null)
        {

            if (blackListTags.Count > 0)
            {
                foreach (var tag in blackListTags)
                {
                    if (categories.Contains(tag))
                    {
                        state = false; break;
                    }
                }
            }

            if (whiteListTags.Count > 0)
            {
                    if (!whiteListTags.Any(tag => tags.Contains(tag)))
                    {
                        state = false;
                    }
            }
        
        }
        return state;
    }
}
